# CPU上下文切换

上一节的例子中 , 多个进程竞争CPU就是一个经常被我们忽视的问题 , 进程在竞争CPU的时候并没有真正运行 , 那系统的负载为什么会升高呢 ? 这就是我们要说的内容 , CPU上下文切换 .

Linux是一个多任务操作系统 , 它支持远大于CPU数量的任务同时运行 . 当然 , 这些任务实际上并不是真的在同时运行 , 而是应为系统在很短的时间内 , 将CPU轮流分配给它们 , 才造成了多任务同时运行的错觉 .

在每个任务运行前 , CPU都需要知道任务从哪里加载 , 又从哪里开始运行 , 也就是需要系统先设置好**CPU寄存器**和**程序计数器** .

* **CPU寄存器**是CPU内置的容量小 , 但速度极快的内存 . 
* **程序计数器**是用来存储CPU正在执行的指令位置 , 或即将执行的下一条指令的位置 . 

它们都是 CPU 在运行任何任务前 , 必须的依赖环境 , 因此也被叫做CPU上下文 .

![](/assets/linux-cpu.png)

**CPU 上下文切换**就是先把前一个任务的CPU上下文\(也就是CPU寄存器和程序计数器\)保存起来 , 然后加载新任务的上下文到这些寄存器和程序计数器 , 最后再跳转到程序计数器所指的新位置 , 运行新任务 .

这些保存下来的上下文 , 会存储在系统内核中 , 并在任务重新调度执行时再次加载进来 . 保证任务原来的状态不受影响 , 让任务看起来还是连续运行的 . 

看几个问题 : 

CPU上下文切换无非就是更新了CPU寄存器的值 , 而且运行速度很快 , 但为什么会影响系统的CPU性能 ? 

这些所谓的任务 , 就是进程线程 , 之外还有那些任务 ? 硬件通过触发信号 , 导致中断处理程序的调用 , 也是一种常见的任务 . 



