# CPU上下文切换

上一节的例子中 , 多个进程竞争CPU就是一个经常被我们忽视的问题 , 进程在竞争CPU的时候并没有真正运行 , 那系统的负载为什么会升高呢 ? 这就是我们要说的内容 , CPU上下文切换 .

Linux是一个多任务操作系统 , 它支持远大于CPU数量的任务同时运行 . 当然 , 这些任务实际上并不是真的在同时运行 , 而是因为系统在很短的时间内 , 将CPU轮流分配给它们 , 才造成了多任务同时运行的错觉 .

在每个任务运行前 , CPU都需要知道任务从哪里加载 , 又从哪里开始运行 , 也就是需要系统先设置好**CPU寄存器**和**程序计数器** .

* **CPU寄存器**是CPU内置的容量小 , 但速度极快的内存 . 
* **程序计数器**是用来存储CPU正在执行的指令位置 , 或即将执行的下一条指令的位置 . 

它们都是 CPU 在运行任何任务前 , 必须的依赖环境 , 因此也被叫做CPU上下文 .

![](/assets/linux-cpu.png)

**CPU 上下文切换**就是先把前一个任务的CPU上下文\(也就是CPU寄存器和程序计数器\)保存起来 , 然后加载新任务的上下文到这些寄存器和程序计数器 , 最后再跳转到程序计数器所指的新位置 , 运行新任务 .

这些保存下来的上下文 , 会存储在系统内核中 , 并在任务重新调度执行时再次加载进来 . 保证任务原来的状态不受影响 , 让任务看起来还是连续运行的 .

看几个问题 :

CPU上下文切换无非就是更新了CPU寄存器的值 , 而且运行速度很快 , 但为什么会影响系统的CPU性能 ?

这些所谓的任务 , 就是进程线程 , 之外还有哪些任务 ? 硬件通过触发信号 , 导致中断处理程序的调用 , 也是一种常见的任务 .

根据任务的不同 , CPU上下文切换分为几个不同的场景 :

进程上下文切换 , 线程上下文切换 , 中断上下文切换 .

#### 进程上下文切换

Linux 按照特权等级 , 把进程的运行空间分为内核空间和用户空间 .

* 内核空间\(Ring 0\) - 具有最高权限 , 可以直接访问所有资源 . 
* 用户空间\(Ring 3\) - 只能访问受限资源 , 不能直接访问内存等硬件设备 , 必须通过系统调用陷入到内核中 , 才能访问这些特权资源 . 

![](/assets/yunxingkongjian.png)

进程在用户空间运行时 , 被称为进程的用户态 , 而陷入内核空间的时候 , 被称为进程的内核态 .

从用户态到内核态的转变 , 需要通过系统调用来完成 . 例如查看文件内容 , 就需要多次系统调用才能完成 , open\(\)打开文件 , read\(\)读取文件 , write\(\)将内容写到标准输出 , 最后close\(\)关闭文件 .

接下来描述下系统调用的过程 . CPU寄存器里原来用户态的指令位置 , 需要先保存起来 . 为了执行内核态代码 , CPU寄存器需要更新为内核态指令的新位置 . 最后跳转到内核态运行内核任务 . 系统调用结束后 , CPU寄存器需要恢复原来保存的用户态 , 然后再切换到用户空间 , 继续运行进程 . 所以 , **一次系统调用的过程 , 其实是发生了两次CPU上下文切换** .

> 需要注意的是 , 系统调用过程中 , 并不会涉及到虚拟内存等进程用户态的资源 , 也不会切换进程 . 也就是说 , 进程上下文切换是从一个进程切换到另一个进程运行 . 而系统调用过程中一直是同一个进程在运行 .

系统调用过程通常称为**特权模式切换** , 而不是上下文切换 . 但实际上系统调用过程中 , CPU的上下文切换还是无法避免的 . 

**进程上下文切换和系统调用的区别**

进程是由内核来管理和调度的 , 进程的切换只能发生在内核态 . 进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源 , 还包括了内核堆栈、寄存器等内核空间的状态 . 

因此 , **进程的上下文切换**就比**系统调用**时多了一步 : 

在保存当前进程的内核状态和CPU寄存器之前 , 需要先把该进在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进...

极客时间版权所有: https://time.geekbang.org/column/article/69859

#### 线程上下文切换

线程与进程最大的区别在于 , 线程是调度的基本单位 , 而进程则是资源拥有的基本单位 . 可以理解为 , 内核中的任务调度 , 实际上的调度对象是线程 , 而进程只是给线程提供了虚拟内存 , 全局变量等资源 .

对于线程和进程的理解 :

* 当进程只有一个线程时 , 可以认为进程就等于线程 . 
* 当进程拥有多个线程时 , 这些线程会共享相同的虚拟内存和全局变量等资源 . 这些资源在上下文切换时是不需要修改的 . 
* 线程也有自己的私有数据 , 比如栈和寄存器等 , 这些在上下文切换时也是需要保存的 . 

线程的上下文切换可以分为两种情况 :

* 第一种 , 前后两个线程属于不同进程 , 因为资源不同享 , 所以切换过程跟进程上下文切换一样
* 第二种 , 前后两个线程属于同一个进程 , 因为虚拟内存是共享的 , 所以在切换时虚拟内存这些资源就保持不动 , 只需要切换线程的私有数据、寄存器等不共享的数据。

虽然同为上下文切换 , 但同进程内的线程切换 , 要比多进程间的切换消耗更少的资源 , 这也是多线程代替多进程的一个优势 .

#### 中断上下文切换



