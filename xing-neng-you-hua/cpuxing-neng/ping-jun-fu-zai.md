# 平均负载

每次发现系统变慢时 , 通常都会执行top或者uptime命令 , 查看平均负载 :

```
➜ ~ uptime
16:47:33 up 5 days,  7:59,  2 users,  load average: 0.00, 0.01, 0.05
```

```
16:47:33              // 当前时间
up 5 days,  7:59      // 系统运行时间
2 user                // 正在登录用户数
// 依次是过去 1 分钟、5 分钟、15 分钟的平均负载
load average: 0.00, 0.01, 0.05
```

#### 平均负载

**平均负载**是指单位时间内 , 系统处于**可运行状态**和**不可中断状态**的平均进程数 , 也就是**平均活跃进程数** , 它和CPU使用率并没有直接关系 .

**可运行状态**

所谓**可运行状态**的进程 , 是指正在使用CPU或者正在等待CPU的进程 , 也就是我们常用ps命令看到的 , 处于R状态\(Running或Runnable\)的进程 .

**不可中断状态**的进程则是正处于内核状态关键流程中的进程 , 并且这些流程是不可打断的 , 比如最常见的是等待硬件设备的I/O响应 , 就是ps命令中看到的D状态\(Uninterruptible Sleep , 也称为Disk Sleep\)的进程 .

比如 , 当一个进程向磁盘读写数据时 , 为了保证数据的一致性 , 在得到磁盘回复前 , 它是不能被其他进程或者中断打断的 , 这个时候的进程就处于不可中断状态 . 如果此时的进程被打断了 , 就容易出现磁盘数据与进程数据不一致的问题 .

所以 , **不可中断状态实际上是系统对进程和硬件设备的一种保护机制** . 平均负载其实就是平均活跃进程数 . 平均活跃进程数直观上理解就是单位时间内的活跃进程数 , 跟进一步理解可以解释为活跃进程数的指数衰减平均值\(指数衰减平均是系统的一种更快的方式\) .

最理想的状态就是每个CPU上刚好运行着一个进程 , 这样每个CPU都得到了充分的利用 . 以平均负载为2举例 :

* 只有2个CPU的系统上 , CPU刚好被完全占用
* 有4个CPU的系统上 , 意味着CPU有50%的空闲
* 只有1个CPU的系统中 , 意味着有一半的进程竞争不到CPU

#### 平均负载为多少时合理

查看系统CPU个数

```
$ grep 'model name' /proc/cpuinfo | wc -l
2
```

通过CPU个数就可以判断平均负载比CPU个数还大的时候 , 系统就出现了过载 . 

根绝uptime提供的三个不同时间间隔的平均负载 , 就可以分析系统负载的基本趋势 . 

