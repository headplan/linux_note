# 平均负载

每次发现系统变慢时 , 通常都会执行top或者uptime命令 , 查看平均负载 :

```
➜ ~ uptime
16:47:33 up 5 days,  7:59,  2 users,  load average: 0.00, 0.01, 0.05
```

```
16:47:33              // 当前时间
up 5 days,  7:59      // 系统运行时间
2 user                // 正在登录用户数
// 依次是过去 1 分钟、5 分钟、15 分钟的平均负载
load average: 0.00, 0.01, 0.05
```

#### 平均负载

**平均负载**是指单位时间内 , 系统处于**可运行状态**和**不可中断状态**的平均进程数 , 也就是**平均活跃进程数** , 它和CPU使用率并没有直接关系 .

**可运行状态**

所谓**可运行状态**的进程 , 是指正在使用CPU或者正在等待CPU的进程 , 也就是我们常用ps命令看到的 , 处于R状态\(Running或Runnable\)的进程 .

**不可中断状态**的进程则是正处于内核状态关键流程中的进程 , 并且这些流程是不可打断的 , 比如最常见的是等待硬件设备的I/O响应 , 就是ps命令中看到的D状态\(Uninterruptible Sleep , 也称为Disk Sleep\)的进程 .

比如 , 当一个进程向磁盘读写数据时 , 为了保证数据的一致性 , 在得到磁盘回复前 , 它是不能被其他进程或者中断打断的 , 这个时候的进程就处于不可中断状态 . 如果此时的进程被打断了 , 就容易出现磁盘数据与进程数据不一致的问题 .

所以 , **不可中断状态实际上是系统对进程和硬件设备的一种保护机制** . 平均负载其实就是平均活跃进程数 . 平均活跃进程数直观上理解就是单位时间内的活跃进程数 , 跟进一步理解可以解释为活跃进程数的指数衰减平均值\(指数衰减平均是系统的一种更快的方式\) .

最理想的状态就是每个CPU上刚好运行着一个进程 , 这样每个CPU都得到了充分的利用 . 以平均负载为2举例 :

* 只有2个CPU的系统上 , CPU刚好被完全占用
* 有4个CPU的系统上 , 意味着CPU有50%的空闲
* 只有1个CPU的系统中 , 意味着有一半的进程竞争不到CPU

#### 平均负载为多少时合理

查看系统CPU个数

```
$ grep 'model name' /proc/cpuinfo | wc -l
2
```

通过CPU个数就可以判断平均负载比CPU个数还大的时候 , 系统就出现了过载 .

根绝uptime提供的三个不同时间间隔的平均负载 , 就可以分析系统负载的基本趋势 :

* 如果1分钟 , 5分钟 , 15分钟的三个值基本相同 , 或者相差不大 , 那就说明系统负载平稳
* 如果1分钟的值远小于15分钟的值 , 说明系统最近1分钟的负载在减少 , 而过去15分钟内却有很大的负载
* 反过来 , 如果 1 分钟的值远大于 15 分钟的值 , 就说明最近1 分钟的负载在增加 , 这种增加有可能只是临时性的 , 也有可能还会持续增加下去 , 所以就需要持续观察 . 一旦 1 分钟的平均负载接近或超过了 CPU 的个数 , 就意味着系统正在发生过载的问题 , 这时就得分析调查是哪里导致的问题 , 并要想办法优化了 . 

再举个例子 , 假设我们在一个单 CPU 系统上看到平均负载为 1.73 , 0.60 , 7.98 , 那么说明在过去 1 分钟内 , 系统有 73% 的超载 , 而在 15 分钟内 , 有 698 % 的超载 , 从整体趋势来看 , 系统的负载在降低 .

> 在实际生产环境中 , 当平均负载高于CPU数量70%的时候 , 就应该排查负载高的问题了 , 当然这也不是绝对的 , 最好还是监控起来 , 根据历史数据去判断 .

#### 平均负载与CPU使用率的区别

**平均负载**是指单位时间内 , 处于可运行状态和不可中断状态的进程数 . 所以 , 它不仅包括了正在使用 CPU 的进程 , 还包括等待 CPU 和等待 I/O 的进程 .

**CPU使用率** , 是单位时间内 CPU 繁忙情况的统计 , 跟平均负载并不一定完全对应 .

* CPU 密集型进程 , 使用大量 CPU 会导致平均负载升高 , 此时这两者是一致的 ; 
* I/O 密集型进程 , 等待 I/O 也会导致平均负载升高 , 但 CPU 使用率不一定很高 ; 
* 大量等待 CPU 的进程调度也会导致平均负载升高 , 此时的 CPU 使用率也会比较高 ; 

---

#### 平均负载案例分析

**工具准备**

**stress**

stress是一个Linux系统压力测试工具 , 这里用作异常进程模拟平均负载升高的场景 .

[http://people.seas.harvard.edu/~apw/stress/](http://people.seas.harvard.edu/~apw/stress/)

```
# yum安装
yum install -y epel-release
yum install -y stress
```

```
# 下载解压
./configure
make
make install
# 默认安装在:/usr/local/bin/stress
```

**sysstat**

sysstat包含了常用的Linux性能工具 , 用来监控和分析系统的性能 .

[https://github.com/sysstat/sysstat](https://github.com/sysstat/sysstat)

```
git clone git://github.com/sysstat/sysstat
cd sysstat
./configure --enable-install-cron
make
make install
```

这里用到sysstat包中的两个命令 :

* **mpstat**是一个常用的多核CPU性能分析工具 , 用来实时查看每个CPU的性能指标 , 以及所有CPU的平均指标 . 
* **pidstat**是一个常用的进程性能分析工具 , 用来实时查看进程的CPU , 内存 , I/O以及上下文切换等性能指标 . 

---

记录测试前的平均负载情况 :

```
uptime
11:28:02 up 1 day,  2:55,  1 user,  load average: 0.00, 0.01, 0.05
```

**场景一 : CPU密集型进程**

模拟一个CPU使用率100%的场景

```
$ stress --cpu 1 --timeout 600
```

在第二个终端运行uptime查看平均负载的变化情况

```
# -d 参数表示高亮显示变化的区域
$ watch -d uptime
```

在第三个终端运行mpstat查看CPU使用率的变化情况

```
# -P ALL 表示监控所有 CPU,后面数字 5 表示间隔 5 秒后输出一组数据
$ mpstat -P ALL 5
14时27分14秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
14时27分19秒  all   25.09    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   74.71
14时27分19秒    0    0.20    0.00    0.40    0.00    0.00    0.00    0.00    0.00    0.00   99.40
14时27分19秒    1  100.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00    0.00
14时27分19秒    2    0.20    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.60
14时27分19秒    3    0.00    0.00    0.20    0.00    0.00    0.00    0.00    0.00    0.00   99.80
```

终端二可以看到 , 1分钟的平均负载会增加到1.00 . 第三个终端可以看出 , CPU的使用率为100% , 但是它的iowait只有0 . 这说明 , 平均负载的升高正是由于CPU使用率为100%

使用pidstat查看到底是哪个进程导致了CPU使用率爆表

```
# 间隔5秒后输出一组数据
pidstat -u 5 1
平均时间:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:  1003      1162    0.20    0.00    0.00    0.00    0.20     -  redis-server
平均时间:  1001      2484    0.20    0.00    0.00    0.00    0.20     -  mysqld
平均时间:     0     11227  100.00    0.00    0.00    0.00  100.00     -  stress
平均时间:     0     11554    0.00    0.20    0.00    0.00    0.20     -  pidstat
平均时间:     0     27788    0.20    0.20    0.00    0.00    0.40     -  watch
```

可以明显看到stress进程的CPU使用率为100% .

**场景二 : I/O密集型进程**

还是运行stress命令 , 模拟I/O压力 , 即不停的执行sync

```
$ stress -i 1 --timeout 600
```

在第二个终端运行uptime查看平均负载的变化情况

```
# -d 参数表示高亮显示变化的区域
$ watch -d uptime
```

第三个终端运行 mpstat 查看 CPU 使用率的变化情况

```
# 显示所有 CPU 的指标，并在间隔 5 秒输出一组数据
$ mpstat -P ALL 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:41:28     CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
13:41:33     all    0.21    0.00   12.07   32.67    0.00    0.21    0.00    0.00    0.00   54.84
13:41:33       0    0.43    0.00   23.87   67.53    0.00    0.43    0.00    0.00    0.00    7.74
13:41:33       1    0.00    0.00    0.81    0.20    0.00    0.00    0.00    0.00    0.00   98.99
```

这里可以看到 , 平均负载的升高是由于iowait的升高 .

和前面一样 , 使用pidstat查看哪个进程导致的

```
# 间隔 5 秒后输出一组数据，-u 表示 CPU 指标
$ pidstat -u 5 1
Linux 4.15.0 (ubuntu)     09/22/18     _x86_64_    (2 CPU)
13:42:08      UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
13:42:13        0       104    0.00    3.39    0.00    0.00    3.39     1  kworker/1:1H
13:42:13        0       109    0.00    0.40    0.00    0.00    0.40     0  kworker/0:1H
13:42:13        0      2997    2.00   35.53    0.00    3.99   37.52     1  stress
13:42:13        0      3057    0.00    0.40    0.00    0.00    0.40     0  pidstat
```

**场景三 : 大量进程的场景**

当系统中运行进程超出 CPU 运行能力时 , 就会出现等待 CPU 的进程 .

使用stress , 模拟8个进程

```
$ stress -c 8 --timeout 600
```

查看平均负载

```
$ uptime
```

查看进程情况

```
# 间隔 5 秒后输出一组数据
➜  ~ pidstat -u 5 1
Linux 3.10.0-862.el7.x86_64 (fuckfair)     2018年12月20日     _x86_64_    (4 CPU)

15时57分39秒   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
15时57分44秒     0     14650   51.29    0.00    0.00   48.31   51.29     0  stress
15时57分44秒     0     14651   48.91    0.00    0.00   51.09   48.91     2  stress
15时57分44秒     0     14652   48.71    0.00    0.00   51.09   48.71     2  stress
15时57分44秒     0     14653   49.70    0.00    0.00   49.90   49.70     3  stress
15时57分44秒     0     14654   49.70    0.00    0.00   49.70   49.70     1  stress
15时57分44秒     0     14655   49.90    0.00    0.00   49.90   49.90     1  stress
15时57分44秒     0     14656   49.90    0.00    0.00   49.90   49.90     3  stress
15时57分44秒     0     14657   50.10    0.00    0.00   49.50   50.10     0  stress
15时57分44秒     0     14861    0.00    0.40    0.00    0.20    0.40     0  pidstat

平均时间:   UID       PID    %usr %system  %guest   %wait    %CPU   CPU  Command
平均时间:     0     14650   51.29    0.00    0.00   48.31   51.29     -  stress
平均时间:     0     14651   48.91    0.00    0.00   51.09   48.91     -  stress
平均时间:     0     14652   48.71    0.00    0.00   51.09   48.71     -  stress
平均时间:     0     14653   49.70    0.00    0.00   49.90   49.70     -  stress
平均时间:     0     14654   49.70    0.00    0.00   49.70   49.70     -  stress
平均时间:     0     14655   49.90    0.00    0.00   49.90   49.90     -  stress
平均时间:     0     14656   49.90    0.00    0.00   49.90   49.90     -  stress
平均时间:     0     14657   50.10    0.00    0.00   49.50   50.10     -  stress
平均时间:     0     14861    0.00    0.40    0.00    0.20    0.40     -  pidstat
```

这里8个进程争抢2个CPU , 每个进程等待CPU的时间 , 也就是%wait列高达75% , 超出CPU计算能力的进程 , 最终导致CPU过载 .

---

#### 总结

平均负载提供了一个快速查看系统整体性能的手段 , 反映了整体的负载情况 . 但只看平均负载本身 , 并不能直接发现到底是哪里出现了瓶颈 , 所以还要注意 : 

* 平均负载高有可能是 CPU 密集型进程导致的
* 平均负载高并不一定代表 CPU 使用率高 , 还有可能是 I/O 更繁忙了
* 当发现负载高的时候 , 你可以使用 mpstat、pidstat等工具 , 辅助分析负载的来源



