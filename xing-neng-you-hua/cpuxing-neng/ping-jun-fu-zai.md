# 平均负载

每次发现系统变慢时 , 通常都会执行top或者uptime命令 , 查看平均负载 :

```
➜ ~ uptime
16:47:33 up 5 days,  7:59,  2 users,  load average: 0.00, 0.01, 0.05
```

```
16:47:33              // 当前时间
up 5 days,  7:59      // 系统运行时间
2 user                // 正在登录用户数
// 依次是过去 1 分钟、5 分钟、15 分钟的平均负载
load average: 0.00, 0.01, 0.05
```

#### 平均负载

**平均负载**是指单位时间内 , 系统处于**可运行状态**和**不可中断状态**的平均进程数 , 也就是**平均活跃进程数** , 它和CPU使用率并没有直接关系 .

**可运行状态**

所谓**可运行状态**的进程 , 是指正在使用CPU或者正在等待CPU的进程 , 也就是我们常用ps命令看到的 , 处于R状态\(Running或Runnable\)的进程 .

**不可中断状态**的进程则是正处于内核状态关键流程中的进程 , 并且这些流程是不可打断的 , 比如最常见的是等待硬件设备的I/O响应 , 就是ps命令中看到的D状态\(Uninterruptible Sleep , 也称为Disk Sleep\)的进程 .

比如 , 当一个进程向磁盘读写数据时 , 为了保证数据的一致性 , 在得到磁盘回复前 , 它是不能被其他进程或者中断打断的 , 这个时候的进程就处于不可中断状态 . 如果此时的进程被打断了 , 就容易出现磁盘数据与进程数据不一致的问题 .

所以 , **不可中断状态实际上是系统对进程和硬件设备的一种保护机制** . 平均负载其实就是平均活跃进程数 . 平均活跃进程数直观上理解就是单位时间内的活跃进程数 , 跟进一步理解可以解释为活跃进程数的指数衰减平均值\(指数衰减平均是系统的一种更快的方式\) .

最理想的状态就是每个CPU上刚好运行着一个进程 , 这样每个CPU都得到了充分的利用 . 以平均负载为2举例 :

* 只有2个CPU的系统上 , CPU刚好被完全占用
* 有4个CPU的系统上 , 意味着CPU有50%的空闲
* 只有1个CPU的系统中 , 意味着有一半的进程竞争不到CPU

#### 平均负载为多少时合理

查看系统CPU个数

```
$ grep 'model name' /proc/cpuinfo | wc -l
2
```

通过CPU个数就可以判断平均负载比CPU个数还大的时候 , 系统就出现了过载 .

根绝uptime提供的三个不同时间间隔的平均负载 , 就可以分析系统负载的基本趋势 :

* 如果1分钟 , 5分钟 , 15分钟的三个值基本相同 , 或者相差不大 , 那就说明系统负载平稳
* 如果1分钟的值远小于15分钟的值 , 说明系统最近1分钟的负载在减少 , 而过去15分钟内却有很大的负载
* 反过来 , 如果 1 分钟的值远大于 15 分钟的值 , 就说明最近1 分钟的负载在增加 , 这种增加有可能只是临时性的 , 也有可能还会持续增加下去 , 所以就需要持续观察 . 一旦 1 分钟的平均负载接近或超过了 CPU 的个数 , 就意味着系统正在发生过载的问题 , 这时就得分析调查是哪里导致的问题 , 并要想办法优化了 . 

再举个例子 , 假设我们在一个单 CPU 系统上看到平均负载为 1.73 , 0.60 , 7.98 , 那么说明在过去 1 分钟内 , 系统有 73% 的超载 , 而在 15 分钟内 , 有 698 % 的超载 , 从整体趋势来看 , 系统的负载在降低 .

> 在实际生产环境中 , 当平均负载高于CPU数量70%的时候 , 就应该排查负载高的问题了 , 当然这也不是绝对的 , 最好还是监控起来 , 根据历史数据去判断 .

#### 平均负载与CPU使用率的区别

**平均负载**是指单位时间内 , 处于可运行状态和不可中断状态的进程数 . 所以 , 它不仅包括了正在使用 CPU 的进程 , 还包括等待 CPU 和等待 I/O 的进程 .

**CPU使用率** , 是单位时间内 CPU 繁忙情况的统计 , 跟平均负载并不一定完全对应 .

* CPU 密集型进程 , 使用大量 CPU 会导致平均负载升高 , 此时这两者是一致的 ; 
* I/O 密集型进程 , 等待 I/O 也会导致平均负载升高 , 但 CPU 使用率不一定很高 ; 
* 大量等待 CPU 的进程调度也会导致平均负载升高 , 此时的 CPU 使用率也会比较高 ; 

---

#### 平均负载案例分析

**工具准备**

**stress**

stress是一个Linux系统压力测试工具 , 这里用作异常进程模拟平均负载升高的场景 .

http://people.seas.harvard.edu/~apw/stress/

```
# yum安装
yum install -y epel-release
yum install -y stress
```

```
# 下载解压
./configure
make
make install
# 默认安装在:/usr/local/bin/stress
```

**sysstat**

sysstat包含了常用的Linux性能工具 , 用来监控和分析系统的性能 .

https://github.com/sysstat/sysstat

```
git clone git://github.com/sysstat/sysstat
cd sysstat
./configure --enable-install-cron
make
make install
```

这里用到sysstat包中的两个命令 : 

mpstat



